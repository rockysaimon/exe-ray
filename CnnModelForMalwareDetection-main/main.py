from load_data import load_data
from resnet_model import build_resnet_model, compile_model
from train_model import train_model
from evaluate_model import evaluate_model
from save_model import save_model

def cargar_datos():
    data_dir = r"C:\Users\zapat\OneDrive\Documentos\cnn\malimg_paper_dataset_imgs"  # Directorio que contiene las carpetas de las clases
    img_size = (200, 200)
    batch_size = 64
    num_classes = 25
    epochs = 7
    model_path = r"C:\Users\zapat\OneDrive\Documentos\cnn\MODELO3_resnet_model_cnn.h5"


    train_generator, validation_generator, test_data, Nombre_famMalware = load_data(data_dir, img_size, batch_size)


    model = build_resnet_model(input_shape=(*img_size, 3), num_classes=num_classes) #*img_size representa la tupla (200,200) y la desempaqueta, y el 1 es que es blanco y negro (3 es RGB)
    compile_model(model)

    return model, test_data, Nombre_famMalware, train_generator, validation_generator, epochs, model_path

if __name__ == "__main__":
    modelo, test_data, clases, train_generator, validation_generator, epochs, model_path_save = cargar_datos()

def Entrenar_modelo(model, train_generator, validation_generator, epochs, model_path):

    history=train_model(model, train_generator, validation_generator, epochs)
    evaluate_model(model, test_data)
    save_model(model, model_path)

    return history

history=Entrenar_modelo(modelo, train_generator, validation_generator, epochs, model_path_save)

#PREUBAS (NO OFICIAL)
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
from tensorflow.keras.models import load_model

def hacer_predicciones(modelo, datos_prueba, mapeo_clases):
    modelo=modelo #para no eliminar al atributo modelo
    modelo_h5=load_model(r"C:\Users\zapat\OneDrive\Documentos\cnn\modelos_entrenados\MODELO3_resnet_model_cnn.h5")
    predicciones = modelo_h5.predict(datos_prueba)
    # sacar las clases predichas para cada imagen
    clases_predichas = [mapeo_clases[np.argmax(prediccion)] for prediccion in predicciones]
    nombres_archivos = datos_prueba.filenames #da el nombre y la carpeta a la que está
    # zip ayuda a pegar los elementos de 2 listas, en este caso, el primer nombre con la primer clase y así sucesivamente
    for nombre_archivo, clase_predicha in zip(nombres_archivos, clases_predichas):
        print(f"Archivo: {nombre_archivo}, Predicción: {clase_predicha}")

hacer_predicciones(modelo, test_data, clases)

#PREUBAS DE PREDICCIÓN CON TEST_DATA(OFICIAL)

def classify_images(test_data, umbral=0.5):
    modelo=load_model(r"C:\Users\zapat\OneDrive\Documentos\cnn\modelos_entrenados\MODELO3_resnet_model_cnn.h5")
    predictions = modelo.predict(test_data)
    classes = list(test_data.class_indices.keys())
    nombres_archivos = test_data.filenames
    
    for i, prediction in enumerate(predictions):
        max_prob = max(prediction)
        max_prob_index = np.argmax(prediction)
        
        if max_prob >= umbral:
            max_prob_class = classes[max_prob_index]
            print(f'Image {i+1}-{nombres_archivos[i]}: Malware - {max_prob_class} (probability: {max_prob})')
        else:
            print(f'Image {i+1}-{nombres_archivos[i]}: No malware (probability: {max_prob})')

classify_images(test_data)

#MÉTRICAS DE CLASIFICACIÓN

#GRAFICA ACCURACCY
def accuracyChart(history):
    plt.plot(history.history['accuracy'])
    plt.plot(history.history['val_accuracy'])
    plt.title('model accuracy')
    plt.ylabel('accuracy')
    plt.xlabel('epoch')
    plt.legend(['train', 'val'], loc='upper left')
    plt.show()

accuracyChart(history)

#GRACFICA LOSS
def lossChart(history):
    plt.plot(history.history['loss'])
    plt.plot(history.history['val_loss'])
    plt.title('model loss')
    plt.ylabel('loss')
    plt.xlabel('epoch')
    plt.legend(['train', 'val'], loc='upper left')
    plt.show()
    
lossChart(history)

# F1-SCORE, PRECISION AND RECALL POR FAMILIAS
def calculate_and_plot_f1_score(model, test_data, classes):
    test_labels = test_data.labels
    predictions = model.predict(test_data)
    predicted_classes = np.argmax(predictions, axis=1)

    # Obtener el reporte de clasificación que incluye el F1-score, recall, precision y el support
    report_str = classification_report(test_labels, predicted_classes, target_names=classes)

    # Imprimir el reporte de clasificación en texto
    print("Reporte:")
    print(report_str)

    # Convertir el reporte de clasificación a un diccionario
    report_dict = classification_report(test_labels, predicted_classes, target_names=classes, output_dict=True)

    # Calcular el F1-score promedio
    f1_score = report_dict['macro avg']['f1-score']
    print(f"El F1-score es: {f1_score}")

    # graficar el F1-score
    plt.figure(figsize=(12, 10))
    plt.bar(classes, [report_dict[c]["precision"] for c in classes], color="blue", alpha=0.5, label="Precision")
    plt.bar(classes, [report_dict[c]["recall"] for c in classes], color="green", alpha=0.5, label="Recall")
    plt.bar(classes, [report_dict[c]["f1-score"] for c in classes], color="orange", alpha=0.5, label="F1-score")
    plt.title("Métricas de clasificación")
    plt.xlabel("Familias de malware")
    plt.ylabel("Score")
    plt.xticks(rotation=45, ha="right")
    plt.legend()
    plt.tight_layout()
    plt.show()

calculate_and_plot_f1_score(modelo, test_data, clases)